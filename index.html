<!DOCTYPE html>
<html>
<head>
    <title>Memory Reconsolidation Visualizer</title>
    <style>
        canvas {
            border: 1px solid #000;
        }
    </style>
</head>
<body style="background-color: black; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0;">
    <canvas id="canvas" width="700" height="700"></canvas>
    <script>
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        class Ball {
            constructor(x, y, radius, color, isRoot) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.childBalls = [];
                this.isRoot = isRoot;
            }

            update() {
                this.x += this.velocityX;
                this.y += this.velocityY;

                for (const childBall of this.childBalls) {
                    childBall.update();
                }

                for (const childBall of this.childBalls) {
                    if (this !== childBall && this.isChildColliding(childBall)) {
                        this.handleCollision(childBall, true);
                    }
                }

                for (let m = 0; m < this.childBalls.length - 1; m++) {
                  let ballM = this.childBalls[m];
                  for (let n = m + 1; n < this.childBalls.length; n++) {
                    let ballN = this.childBalls[n];
                    if (ballM !== ballN && ballM.isSiblingColliding(ballN)) {
                        ballM.handleCollision(ballN, false);
                    }
                  }
                }
            }

            isChildColliding(child) {
                const dx = this.x - child.x;
                const dy = this.y - child.y;
                const distanceSquared = dx * dx + dy * dy;
                return distanceSquared > (this.radius - child.radius) * (this.radius - child.radius);   
            }

            isSiblingBoundingBoxColliding(sibling) {
                if (Math.abs(this.x - sibling.x) > this.radius + sibling.radius)
                    return false;
                if (Math.abs(this.y - sibling.y) > this.radius + sibling.radius)
                    return false;
                return true;
            }

            isSiblingColliding(sibling) {
                if (!this.isSiblingBoundingBoxColliding(sibling))
                    return false;
                const dx = this.x - sibling.x;
                const dy = this.y - sibling.y;
                const distanceSquared = dx * dx + dy * dy;
                return distanceSquared < (this.radius + sibling.radius) * (this.radius + sibling.radius);
            }

            handleCollision(other, isParent) {
                const energyConserved = 1.000;

                const dx = other.x - this.x;
                const dy = other.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                const normalX = dx / distance;
                const normalY = dy / distance;

                const relativeVelocityX = other.velocityX - this.velocityX;
                const relativeVelocityY = other.velocityY - this.velocityY;
                const relativeVelocityInNormalDirection = normalX * relativeVelocityX + normalY * relativeVelocityY;

                const overlap = isParent
                    ? (this.radius - other.radius - distance)
                    : (this.radius + other.radius - distance) / 2;
                if (isParent && overlap >= 0)
                    return;
                if (!isParent && relativeVelocityInNormalDirection > 0)
                    return;
                if (this.isRoot) {
                    const thisMass = Math.PI * this.radius * this.radius;
                    const otherMass = Math.PI * other.radius * other.radius;
                    const massSum = thisMass + otherMass;
                    const impulse = 2 * relativeVelocityInNormalDirection * energyConserved;

                    other.x += overlap * normalX;
                    other.y += overlap * normalY;
                    other.velocityX -= impulse * normalX;
                    other.velocityY -= impulse * normalY;
                } else {
                    const thisMass = Math.PI * this.radius * this.radius;
                    const otherMass = Math.PI * other.radius * other.radius;
                    const massSum = thisMass + otherMass;
                    const thisMassProportion = thisMass / massSum;
                    const otherMassProportion = 1 - thisMassProportion;

                    const impulse = 2 * relativeVelocityInNormalDirection * energyConserved;
                    const thisImpulse = impulse * thisMassProportion;
                    const otherImpulse = impulse * otherMassProportion;

                    this.x -= overlap * normalX * otherMassProportion;
                    this.y -= overlap * normalY * otherMassProportion;
                    this.velocityX += otherImpulse * normalX;
                    this.velocityY += otherImpulse * normalY;

                    other.x += overlap * normalX * thisMassProportion;
                    other.y += overlap * normalY * thisMassProportion;
                    other.velocityX -= thisImpulse * normalX;
                    other.velocityY -= thisImpulse * normalY;
                }
            }

            generateChildren(levelsLeft) {
                //const color = ["red", "orange", "yellow", "green", "blue", "purple"][levelsLeft];
                const color = "white";
                for (let n = 0; n < 10; n++) {
                    const childBall = new Ball(this.x, this.y, this.radius / 5, color, false);
                    childBall.velocityX = Math.random() * 5 - (5 / 2);
                    childBall.velocityY = Math.random() * 5 - (5 / 2);
                    this.childBalls.push(childBall);
                    if (levelsLeft > 1)
                      childBall.generateChildren(levelsLeft - 1);
                }
            }

            drawThisAndChildren(parent) {
                this.draw();
                for (const childBall of this.childBalls) {
                    childBall.drawThisAndChildren(this);
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.closePath();
            }
        }

        const mainBall = new Ball(canvas.width / 2, canvas.height / 2, canvas.height / 2, "white", true);
        mainBall.velocityX = 0;
        mainBall.velocityY = 0;
        mainBall.generateChildren(3);

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            mainBall.update();
            mainBall.drawThisAndChildren();

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
