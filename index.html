<!DOCTYPE html>
<html>
<head>
    <title>Bouncing Ball Engine with Collisions</title>
    <style>
        canvas {
            border: 1px solid #000;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="600" height="400"></canvas>
    <script>
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        class Ball {
            constructor(x, y, radius, color, isRoot) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.childBalls = [];
                this.isRoot = isRoot;
            }

            update() {
                this.x += this.velocityX;
                this.y += this.velocityY;

                for (const childBall of this.childBalls) {
                    childBall.update();
                }

                for (const childBall of this.childBalls) {
                    if (this !== childBall && this.isChildColliding(childBall)) {
                        this.handleCollision(childBall, true);
                    }
                }

                for (let m = 0; m < this.childBalls.length - 1; m++) {
                  let ballM = this.childBalls[m];
                  for (let n = m + 1; n < this.childBalls.length; n++) {
                    let ballN = this.childBalls[n];
                    if (ballM !== ballN && ballM.isSiblingColliding(ballN)) {
                        ballM.handleCollision(ballN, false);
                    }
                  }
                }
            }

            isChildColliding(child) {
                const dx = this.x - child.x;
                const dy = this.y - child.y;
                const distanceSquared = dx * dx + dy * dy;
                return distanceSquared > (this.radius - child.radius) * (this.radius - child.radius);   
            }

            handleChildCollision(child) {
                const energyConserved = 1.0;

                const dx = child.x - this.x;
                const dy = child.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Calculate the unit normal vector
                const normalX = dx / distance;
                const normalY = dy / distance;

                // Calculate the relative velocity components
                const relativeVelocityX = child.velocityX - this.velocityX;
                const relativeVelocityY = child.velocityY - this.velocityY;

                // Calculate the relative velocity in the direction of the normal vector
                const relativeVelocityInNormalDirection = normalX * relativeVelocityX + normalY * relativeVelocityY;

                const overlap = this.radius - (distance + child.radius);

                // Check if the child ball is moving towards the parent circle
                //if (relativeVelocityInNormalDirection > 0) {
                if (overlap < 0) {
                    // Calculate the impulse (change in velocity) for the child ball
                    const impulse = -2 * relativeVelocityInNormalDirection * energyConserved;

                    // Apply the impulse to the child ball's velocities
                    child.velocityX += impulse * normalX;
                    child.velocityY += impulse * normalY;

                    // Separate the child ball from the parent circle to prevent overlap
                    const overlapX = overlap * normalX;
                    const overlapY = overlap * normalY;
                    child.x += overlapX;
                    child.y += overlapY;
                }
            }

            isSiblingBoundingBoxColliding(sibling) {
                if (Math.abs(this.x - sibling.x) > this.radius + sibling.radius)
                    return false;
                if (Math.abs(this.y - sibling.y) > this.radius + sibling.radius)
                    return false;
                return true;
            }

            isSiblingColliding(sibling) {
                if (!this.isSiblingBoundingBoxColliding(sibling))
                    return false;
                const dx = this.x - sibling.x;
                const dy = this.y - sibling.y;
                const distanceSquared = dx * dx + dy * dy;
                return distanceSquared < (this.radius + sibling.radius) * (this.radius + sibling.radius);
            }

            handleSiblingCollision(sibling) {
                const energyConserved = 1.0;

                const dx = sibling.x - this.x;
                const dy = sibling.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Calculate the unit normal vector
                const normalX = dx / distance;
                const normalY = dy / distance;

                // Calculate the relative velocity components
                const relativeVelocityX = sibling.velocityX - this.velocityX;
                const relativeVelocityY = sibling.velocityY - this.velocityY;

                // Calculate the relative velocity in the direction of the normal vector
                const relativeVelocityInNormalDirection = normalX * relativeVelocityX + normalY * relativeVelocityY;

                // Check if the balls are moving toward each other
                if (relativeVelocityInNormalDirection < 0) {
                    // Calculate the impulse (change in velocity) based on the masses of the balls
                    const massSum = this.radius + sibling.radius;
                    const impulse = (2 * relativeVelocityInNormalDirection) / massSum * energyConserved;

                    // Apply the impulse to the velocities
                    this.velocityX += impulse * normalX * sibling.radius;
                    this.velocityY += impulse * normalY * sibling.radius;
                    sibling.velocityX -= impulse * normalX * this.radius;
                    sibling.velocityY -= impulse * normalY * this.radius;

                    // Separate the balls to prevent overlapping
                    const overlap = (this.radius + sibling.radius - distance) / 2;
                    const overlapX = overlap * normalX;
                    const overlapY = overlap * normalY;
                    this.x -= overlapX;
                    this.y -= overlapY;
                    sibling.x += overlapX;
                    sibling.y += overlapY;
                }
            }

            handleCollision(other, isParent) {
                const energyConserved = 1.000;

                const dx = other.x - this.x;
                const dy = other.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Calculate the unit normal vector
                const normalX = dx / distance;
                const normalY = dy / distance;

                // Calculate the relative velocity components
                const relativeVelocityX = other.velocityX - this.velocityX;
                const relativeVelocityY = other.velocityY - this.velocityY;

                // Calculate the relative velocity in the direction of the normal vector
                const relativeVelocityInNormalDirection = normalX * relativeVelocityX + normalY * relativeVelocityY;

                const overlap = isParent
                    ? (this.radius - other.radius - distance)
                    : (this.radius + other.radius - distance) / 2;
                const doHandleCollision = isParent
                    ? overlap < 0
                    : relativeVelocityInNormalDirection < 0

                // Check if the balls are moving toward each other
                if (doHandleCollision) {
                    const thisMass = Math.PI * this.radius * this.radius;
                    const otherMass = Math.PI * other.radius * other.radius;
                    const massSum = thisMass + otherMass;
                    const thisMassProportion = thisMass / massSum;
                    const otherMassProportion = 1 - thisMassProportion;

                    const impulse = 2 * relativeVelocityInNormalDirection * energyConserved;
                    const thisImpulse = impulse * thisMassProportion;
                    const otherImpulse = impulse * otherMassProportion;

                    other.x += overlap * normalX * thisMassProportion;
                    other.y += overlap * normalY * thisMassProportion;
                    other.velocityX -= thisImpulse * normalX;
                    other.velocityY -= thisImpulse * normalY;
                    if (!this.isRoot) {
                        this.x -= overlap * normalX * otherMassProportion;
                        this.y -= overlap * normalY * otherMassProportion;
                        this.velocityX += otherImpulse * normalX;
                        this.velocityY += otherImpulse * normalY;
                    }
                }
            }

            drawThisAndChildren(parent) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();

                for (const childBall of this.childBalls) {
                    childBall.drawThisAndChildren(this);
                }
            }

            generateChildren(levelsLeft) {
                const color = ["black", "green", "red", "yellow", "purple", "orange"][levelsLeft];
                for (let n = 0; n < 10; n++) {
                    const childBall = new Ball(this.x, this.y, this.radius / 5, color, false);
                    childBall.velocityX = Math.random() * 5;
                    childBall.velocityY = Math.random() * 5;
                    this.childBalls.push(childBall);
                    if (levelsLeft > 0)
                      childBall.generateChildren(levelsLeft - 1);
                }
            }
        }

        const mainBall = new Ball(canvas.width / 2, canvas.height / 2, 200, "blue", true);
        mainBall.velocityX = 0;
        mainBall.velocityY = 0;
        mainBall.generateChildren(2);

/*
        for (let level = 0; level < 3; level++) {
          const childBall = new Ball(mainBall.x, mainBall.y, 40, "red", false);
            childBall.velocityX = Math.random() * 5;
            childBall.velocityY = Math.random() * 5;
            mainBall.childBalls.push(childBall);
        }

        for (let i = 0; i < 10; i++) {
            const childBall = new Ball(mainBall.x, mainBall.y, 40, "red", false);
            childBall.velocityX = Math.random() * 5;
            childBall.velocityY = Math.random() * 5;
            mainBall.childBalls.push(childBall);

            for (let j = 0; j < 10; j++) {
                const grandChildBall = new Ball(childBall.x, childBall.y, 4, "green", false);
                grandChildBall.velocityX = 0;
                grandChildBall.velocityY = 0;
                childBall.childBalls.push(grandChildBall);

                for (let k = 0; k < 10; k++) {
                    const greatGrandChildBall = new Ball(grandChildBall.x, grandChildBall.y, 1, "black", false);
                    greatGrandChildBall.velocityX = 0;
                    greatGrandChildBall.velocityY = 0;
                    grandChildBall.childBalls.push(greatGrandChildBall);
                }
            }
        }
        */

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            mainBall.update();
            mainBall.drawThisAndChildren();

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
